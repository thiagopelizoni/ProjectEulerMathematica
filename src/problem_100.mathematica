(*
  Project Euler Problem 100: Arranged Probability
  URL: https://projecteuler.net/problem=100

  Problem Statement:
  A box contains b blue discs and r red discs, giving a total of n = b + r discs. The probability of drawing two blue
  discs at random is exactly 1/2. We are tasked with finding the number of blue discs b in the first arrangement
  where the total number of discs n exceeds 10^12.

  Mathematical Analysis:
  The probability condition corresponds to the equation (b/n) * ((b-1)/(n-1)) = 1/2, which simplifies to the
  quadratic Diophantine equation 2b(b - 1) = n(n - 1). Using the substitutions X = 2n - 1 and Y = 2b - 1, this
  transforms into the negative Pell equation X^2 - 2Y^2 = -1. The fundamental solution to u^2 - 2v^2 = -1 is (1, 1).
  All positive integer solutions (X_k, Y_k) are generated by the odd powers of the fundamental unit (1 + Sqrt[2]) in
  the ring Z[Sqrt[2]]. Specifically, X_k + Y_k*Sqrt[2] = (1 + Sqrt[2])^k for k = 1, 3, 5, ...
  This recurrence is efficiently computed using matrix exponentiation with M = {{1, 2}, {1, 1}}. The values grow
  exponentially with a ratio of approximately 5.8 (square of the fundamental unit). Since we require n > 10^12,
  X must exceed 2*10^12. Solving (1 + Sqrt[2])^k approx 2*10^12 gives k approx 33. The algorithm generates solutions
  for odd k around this value and finds the first valid n. The complexity is logarithmic relative to the target n.

  Parallelization Strategy:
  We identify a search range for the exponent k (e.g., odd integers from 1 to 61) that comfortably covers the
  threshold. We use `ParallelMap` to compute the matrix powers for these exponents concurrently across available
  cores. The results are then filtered sequentially to find the smallest n satisfying the constraint, ensuring
  correctness while distributing the arithmetic load.

  Wolfram Language Implementation:
  - Detect core count.
  - Define the generator matrix {{1, 2}, {1, 1}}.
  - Generate a list of odd exponents.
  - Use `ParallelMap` to compute the (X, Y) pairs via `MatrixPower`.
  - Transform results to (n, b) coordinates.
  - Extract the first solution with n > 10^12.
*)

solve[] := Module[{nCores, matrix, exponents, candidates, validSolution},
  nCores = $ProcessorCount;
  
  matrix = {{1, 2}, {1, 1}};
  
  exponents = Range[1, 61, 2];
  
  candidates = ParallelMap[
    MatrixPower[matrix, #, {1, 0}] &,
    exponents,
    Method -> "CoarsestGrained"
  ];
  
  validSolution = SelectFirst[
    candidates,
    Function[pair, (pair[[1]] + 1)/2 > 10^12]
  ];
  
  (validSolution[[2]] + 1) / 2
];

solve[]