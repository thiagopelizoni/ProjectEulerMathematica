(*
  Problem: Project Euler 58 - Spiral Primes.
  
  Mathematical Analysis:
  We investigate the asymptotic density of prime numbers distributed along the principal diagonals 
  of an Ulam spiral generated by the recursive arrangement of natural numbers. For a square spiral 
  of side length s (where s is an odd integer), the four corner elements are defined by the quadratic 
  set {s^2 - 3(s - 1), s^2 - 2(s - 1), s^2 - (s - 1), s^2}. Noting that s^2 is composite for all s > 1, 
  the primality test is restricted to the remaining three corners per layer. The objective is to 
  determine the minimal s such that the cumulative ratio of primes to total diagonal elements converges 
  strictly below 0.1.

  Computational Strategy:
  Given the indeterminacy of the termination condition (unknown horizon), a standard functional 
  nesting is unsuitable. We employ a speculative batching architecture:
  1. Vectorization: Candidate layers are generated in discrete batches (blocks of 2,000 iterations) 
     to amortize the overhead of symbolic transfer between the master kernel and subkernels.
  2. Distributed Bernoulli Trials: The primality of the candidate set is evaluated via `ParallelMap` 
     using the Rabin-Miller strong pseudoprime test (`PrimeQ`), fully saturating the available 
     thread pool ($ProcessorCount).
  3. Sequential Convergence Check: Results are aggregated serially within the master process to 
     preserve the causal ordering of the ratio evolution, ensuring precise identification of the 
     boundary condition.
*)

Module[{
    side = 1, 
    primeCount = 0, 
    totalDiagonals = 1, 
    limit = 0.10, 
    batchSize = 2000, 
    converged = False, 
    solution,
    candidates,
    primeResults,
    currentSides
  },
  
  If[Length[Kernels[]] < $ProcessorCount, LaunchKernels[$ProcessorCount]];

  While[!converged,
    currentSides = Range[side + 2, side + 2 * batchSize, 2];
      
    candidates = Flatten[Table[
       {s^2 - 3(s - 1), s^2 - 2(s - 1), s^2 - (s - 1)}, 
       {s, currentSides}
    ]];

    primeResults = ParallelMap[Boole[PrimeQ[#]] &, candidates];

    Do[
       primeCount += Total[primeResults[[3 * (i - 1) + 1 ;; 3 * i]]];
       totalDiagonals += 4;
       
       If[primeCount / totalDiagonals < limit,
          solution = currentSides[[i]];
          converged = True;
          Break[]
       ],
       {i, 1, Length[currentSides]}
    ];
    
    side = Last[currentSides];
  ];
  
  solution
]